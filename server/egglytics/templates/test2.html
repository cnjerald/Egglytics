<!DOCTYPE html>
<html>
<head>
    <title>Centered Zoom and Pan Image</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #photo {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            background-color: #f5f5f5;
            cursor: crosshair;
            display: flex;
            justify-content: center;
            align-items: center;
            image-rendering: pixelated;
            will-change: transform;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            contain: strict;
        }

        #zoom-wrapper {
            position: absolute;
            will-change: transform;
            transform: translate(0px, 0px) scale(1);
        }

        #zoom-image {
            user-select: none;
            max-width: none;
            display: block;
            -webkit-user-drag: none;
        }
        #grid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /*As this is on top of the image, i want it to allow mouse to pass */
        }
    </style>
</head>
<body>

<div id="photo">
    <div id="zoom-wrapper">
        <img id="image" src="../static/img/calibrator2.jpg" alt="Zoomable Image">
        <canvas id="grid-canvas"></canvas>
    </div>
</div>

<script>

    const container = document.getElementById('photo');
    const wrapper = document.getElementById('zoom-wrapper');
    const img = document.getElementById('image'); 

    /* Grids */
    const filledCells = new Set();
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 500;

    /* Initial Image Resize */
    let scale = 1;
    let minScale = 0;
    let maxScale = 0;
    let tolerance_reset = 0;

    /* Translation X and Y*/
    let translateX = 0;
    let translateY = 0;
    
    /* Mouse Position */
    let mouseX = 0;
    let mouseY = 0;

    /* States */
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    let lastMouseX = 0;
    let lastMouseY = 0;

    /* Point Storage */
    const drawnPoints = [];

    // Dynamically load the minimum zoom
    img.onload = function () {
        const containerRect = container.getBoundingClientRect();
        const imgNaturalWidth = img.naturalWidth;
        const imgNaturalHeight = img.naturalHeight;
        
        // Rescale image
        const scaleX = containerRect.width / imgNaturalWidth;
        const scaleY = containerRect.height / imgNaturalHeight;

        minScale = Math.min(scaleX, scaleY);
        scale = minScale;
        maxScale = minScale + 1;
        tolerance_reset = maxScale * 0.005;

        translateX = 0;
        translateY = 0;

        canvas.width = img.width;
        canvas.height = img.height;
        
        drawGrid();
        updateTransform();
    };

    // This draws the grids over time image.
    function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;

        // Vertical lines
        for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        }

        // Horizontal lines
        for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        }
    }

    // This updates the image based on 
    // (1) Translation 
    // (2) Zoom/Scale
    function updateTransform() {
        wrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    // Zoom Event Listener (Center Mouse Wheel)
    let zoomPending = false;
    let pendingWheelEvent = null;

    // Throttled wheel event listener
    let zoomVelocity = 0;
    let isZooming = false;

    container.addEventListener('wheel', (e) => {
        e.preventDefault();

        const delta = -e.deltaY * 0.0001; // Negative for natural scroll
        zoomVelocity += delta;

        if (!isZooming) {
            isZooming = true;
            requestAnimationFrame(applyZoom);
        }
    });

    function applyZoom() {
        if (Math.abs(zoomVelocity) < 0.001) {
            zoomVelocity = 0;
            isZooming = false;
            return;
        }

        const newScale = scale * (1 + zoomVelocity);

        // Guard against limits
        if (newScale < minScale || newScale > maxScale) {
            zoomVelocity = 0;
            isZooming = false;
            return;
        }

        const rect = container.getBoundingClientRect();
        const mouseX = lastMouseX ?? rect.width / 2;
        const mouseY = lastMouseY ?? rect.height / 2;

        // Calculate world (pre-zoom) coordinates BEFORE updating scale
        const zoomCenterX = (translateX) / scale;
        const zoomCenterY = (translateY) / scale;

        // Set new scale
        scale = newScale;

        // Adjust pan so zoom stays centered on the mouse
        translateX = zoomCenterX * scale;
        translateY = zoomCenterY * scale;

        // Snap to default if extremely close to min
        if (Math.abs(scale - minScale) < tolerance_reset) {
            translateX = 0;
            translateY = 0;
        }

        updateTransform();

        // Decay zoom velocity (Higher leads to faster zoom)
        zoomVelocity *= 0.95;

        requestAnimationFrame(applyZoom);
    }





    // Track last mouse position over the image (Useful for finding exact pixel)
    img.addEventListener('mousemove', function (e) {
        const rect = img.getBoundingClientRect();
        lastMouseX = e.clientX - rect.left;
        lastMouseY = e.clientY - rect.top;
    });

    // Event listener of middle button hold to pan the image
    container.addEventListener('mousedown', function (e) {
        if (e.button !== 1) return;
        isDragging = true;
        container.style.cursor = 'grabbing';
        startX = e.clientX - translateX;
        startY = e.clientY - translateY;
    });
    // This is to return the cursor from 'grabbing' state to 'crosshair' state
    window.addEventListener('mouseup', function () {
        isDragging = false;
        container.style.cursor = 'crosshair';
    });
    // This updates the translation of the image in case a pan was made.
    container.addEventListener('mousemove', function (e) {
        if (!isDragging) return;
        translateX = e.clientX - startX;
        translateY = e.clientY - startY;
        updateTransform();
    });
    
    // Listen for key press (Q)
    window.addEventListener('keydown', function (e) {
        if (e.key.toLowerCase() === 'q') {
            const rect = img.getBoundingClientRect();

            // Use last known position
            const clickX = lastMouseX;
            const clickY = lastMouseY;

            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;

            const pixelX = Math.floor(clickX * scaleX);
            const pixelY = Math.floor(clickY * scaleY);

            alert(`Pressed Q at pixel: (${pixelX}, ${pixelY})`);
        }
    });

    // Press 'w' to shade the hovered grid cell
    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'w') {
            const relativeX = (lastMouseX) / scale;
            const relativeY = (lastMouseY) / scale;

            console.log(`Mapped X: ${relativeX}, Y: ${relativeY}`);
            fillGridCell(relativeX, relativeY);
        }
    });

    // Press 'e' to create a point
    let eKeyIsDown = false;

    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'e' && !eKeyIsDown) {
            eKeyIsDown = true;

            const rect = img.getBoundingClientRect();

            // Use last known position
            const clickX = lastMouseX;
            const clickY = lastMouseY;

            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;

            const pixelX = Math.floor(clickX * scaleX);
            const pixelY = Math.floor(clickY * scaleY);
            drawPoint(pixelX, pixelY);
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key.toLowerCase() === 'e') {
            eKeyIsDown = false;
        }
    });
    // Press 'r' to erase a point
    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') {
            const rect = img.getBoundingClientRect();

            // Use last known position
            const clickX = lastMouseX;
            const clickY = lastMouseY;

            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;

            const pixelX = Math.floor(clickX * scaleX);
            const pixelY = Math.floor(clickY * scaleY);
            erasePointAtCursor(pixelX,pixelY);
        }
    });


    // This function fills a grid cell by a shade of white to record it as completed, user can also unfill it.
    function fillGridCell(x, y) {
        const col = Math.floor(x / gridSize);
        const row = Math.floor(y / gridSize);
        const key = `${col},${row}`;

        const cellX = col * gridSize;
        const cellY = row * gridSize;

        if (filledCells.has(key)) {
            // Toggle off
            filledCells.delete(key);
            // Clear the cell by redrawing from the image
            ctx.clearRect(cellX, cellY, gridSize, gridSize);
            ctx.drawImage(img, cellX, cellY, gridSize, gridSize, cellX, cellY, gridSize, gridSize);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.strokeRect(cellX, cellY, gridSize, gridSize);
        } else {
            // Toggle on
            filledCells.add(key);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; // semi-transparent white
            ctx.fillRect(cellX, cellY, gridSize, gridSize);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.strokeRect(cellX, cellY, gridSize, gridSize);
        }
    }

    // This function draws a point.
    function drawPoint(x, y, color = 'red', radius = 5) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();

        drawnPoints.push({ x, y });
    }

    function erasePointAtCursor(mouseX, mouseY) {
        const threshold = 10;
        const thresholdSq = threshold * threshold;

        for (let i = drawnPoints.length - 1; i >= 0; i--) {
            const pt = drawnPoints[i];
            const dx = pt.x - mouseX;
            const dy = pt.y - mouseY;
            const distSq = dx * dx + dy * dy;

            if (distSq <= thresholdSq) {
                drawnPoints.splice(i, 1);
                // Just clear 
                ctx.clearRect(pt.x - threshold - 1, pt.y - threshold - 1, threshold * 2 + 2, threshold * 2 + 2);
            }
        }

    }


    

</script>

</body>
</html>
